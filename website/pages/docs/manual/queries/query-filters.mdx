
Filter query results / search queries
=====================================

Table of contents

The **where** argument
----------------------

You can use the `where` argument in your queries to filter results based
on some field's values (even nested objects\' fields). You can even use
multiple filters in the same `where` clause using the `_and` or the
`_or` operators.

For example, to fetch data for an author whose name is \"Sidney\":

```graphql
query {
  author(
    where: {name: {_eq: "Sidney"}}
  ) {
    id
    name
  }
}
```

You can also use nested objects\` fields to filter rows from a table and
also filter the nested objects as well.

For example, to fetch a list of authors who have articles with a rating
greater than 4 along with those articles:

```graphql
query {
  author (where: {articles: {rating: {_gt: 4}}}) {
    id
    name
    articles (where: {rating: {_gt: 4}}) {
      id
      title
      rating
    }
  }
}
```

Here `_eq` and `_gt` are examples of comparison operators that can be
used in the `where` argument to filter on equality.

You can see the complete specification of the `where` argument in the
`API reference <WhereExp>`{.interpreted-text role="ref"}.

Comparision operators
---------------------

Let's take a look at different comparision operators that can be used to
filter results.

### Equality operators (\_eq, \_neq)

The `_eq` (equal to) or the `_neq` (not equal to) operators are
compatible with any Postgres type other than `json` or `jsonB` (like
`Integer`, `Float`, `Double`, `Text`, `Boolean`,
`Date`/`Time`/`Timestamp`, etc.).

For more details on equality operators and Postgres equivalents, refer
to the `API reference <generic_operators>`{.interpreted-text
role="ref"}.

The following are examples of using the equality operators on different
types.

**Example: Integer (works with Double, Float, Numeric, etc.)**

Fetch data about author whose `id` *(an integer field)* is equal to 3:

  author(
    where: {id: {_eq: 3}}
  ) {
    id
    name
  }


**Example: String or Text**

Fetch a list of authors with `name` *(a text field)* as \"Sidney\":

  author(
    where: {name: {_eq: \"Sidney\"}}
  ) {
    id
    name
  }


**Example: Boolean**

Fetch a list of articles that have not been published (`is_published` is
a boolean field):

  article(
    where: {is_published: {_eq: false}}
  ) {
    id
    title
    is_published
  }


**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on a certain date
(`published_on` is a Date field):

  article(
    where: {published_on: {_eq: \"2017-05-26\"}}
  ) {
    id
    title
    published_on
  }


### Greater than or less than operators (\_gt, \_lt, \_gte, \_lte)

The `_gt` (greater than), `_lt` (less than), `_gte` (greater than or
equal to), `_lte` (less than or equal to) operators are compatible with
any Postgres type other than `json` or `jsonB` (like `Integer`, `Float`,
`Double`, `Text`, `Boolean`, `Date`/`Time`/`Timestamp`, etc.).

For more details on greater than or less than operators and Postgres
equivalents, refer to the
`API reference <generic_operators>`{.interpreted-text role="ref"}.

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 4 or more (`rating` is an integer field):

  article(
    where: {rating: {_gte: 4}}
  ) {
    id
    title
    rating
  }


**Example: String or Text**

Fetch a list of authors whose names begin with M or any letter that
follows M *(essentially, a filter based on a dictionary sort)*:

  author(
    where: {name: {_gt: \"M\"}}
  ) {
    id
    name
  }


**Example: Date (works with Time, Timezone, etc.)**

Fetch a list of articles that were published on or after date
\"01/01/2018\":

  article(
    where: {published_on: {_gte: \"2018-01-01\"}}
  ) {
    id
    title
    published_on
  }


### List based search operators (\_in, \_nin)

The `_in` (in a list) and `_nin` (not in list) operators are used to
compare field values to a list of values. They are compatible with any
Postgres type other than `json` or `jsonB` (like `Integer`, `Float`,
`Double`, `Text`, `Boolean`, `Date`/`Time`/`Timestamp`, etc.).

For more details on list based search operators and Postgres
equivalents, refer to the
`API reference <generic_operators>`{.interpreted-text role="ref"}.

The following are examples of using these operators on different types:

**Example: Integer (works with Double, Float, etc.)**

Fetch a list of articles rated 1, 3 or 5:

  article(
    where: {rating: {_in: [1,3,5]}}
  ) {
    id
    title
    rating
  }


**Example: String or Text**

Fetch a list of those authors whose names are NOT part of a list:

  author(
    where: {name: {_nin: [\"Justin\",\"Sidney\",\"April\"]}}
  ) {
    id
    name
  }


### Text search or pattern matching operators (\_like, \_similar, etc.)

The `_like`, `_nlike`, `_ilike`, `_nilike`, `_similar`, `_nsimilar`
operators are used for pattern matching on string/text fields.

For more details on text search operators and Postgres equivalents,
refer to the `API reference <text_operators>`{.interpreted-text
role="ref"}.

**Example: \_like**

Fetch a list of articles whose titles contain the word "amet":

  article(
    where: {title: {_like: \"%amet%\"}}
  ) {
    id
    title
  }


Note

`_like` is case-sensitive. Use `_ilike` for case-insensitive search.

**Example: \_similar**

Fetch a list of authors whose names begin with A or C:

  author(
    where: {name: {_similar: \"(A|C)%\"}}
  ) {
    id
    name
  }


Note

`_similar` is case-sensitive

### JSONB operators (\_contains, \_has\_key, etc.)

The `_contains`, `_contained_in`, `_has_key`, `_has_keys_any` and
`_has_keys_all` operators are used to filter based on `JSONB` columns.

For more details on JSONB operators and Postgres equivalents, refer to
the `API reference <jsonb_operators>`{.interpreted-text role="ref"}.

**Example: \_contains**

Fetch all authors living within a particular pincode (present in
`address` JSONB column):

  author(
    where: {
      address: {_contains: $jsonFilter }
    }
  ) {
    id
    name
    address
  }


**Example: \_has\_key**

Fetch authors if the `phone` key is present in their JSONB `address`
column:

  author(
    where: {
      address: {_has_key: \"phone\" }
    }
  ) {
    id
    name
    address
  }


### PostGIS spatial relationship operators (\_st\_contains, \_st\_crosses, etc.)

The `_st_contains`, `_st_crosses`, `_st_equals`, `_st_intersects`,
`_st_overlaps`, `_st_touches`, `_st_within` and `_st_d_within` operators
are used to filter based on `geometry` like columns.

`_st_d_within` and `_st_intersects` can be used on `geography` columns
also.

For more details on spatial relationship operators and Postgres
equivalents, refer to the
`API reference <geometry_operators>`{.interpreted-text role="ref"}.

Use JSON representation (see
[GeoJSON](https://tools.ietf.org/html/rfc7946)) of `geometry` and
`geography` values in `variables` as shown in the following examples:

**Example: \_st\_within**

Fetch a list of geometry values which are within the given `polygon`
value:

  geom_table(
    where: {geom_col: {_st_within: $polygon}}
  ){
    id
    geom_col
  }


**Example: \_st\_d\_within**

Fetch a list of `geometry` values which are 3 units from given `point`
value:

  geom_table(
    where: {geom_col: {_st_d_within: {distance: 3, from: $point}}}
  ){
    id
    geom_col
  }


### Filter or check for null values (\_is\_null)

Checking for null values can be achieved using the `_is_null` operator.

For more details on the `_is_null` operator and Postgres equivalent,
refer to the `API reference <null_expression>`{.interpreted-text
role="ref"}.

**Example: Filter null values in a field**

Fetch a list of articles that have a value in the `published_on` field:

  article(
    where: {published_on: {_is_null: false}}
  ) {
    id
    title
    published_on
  }


### Intersect operators on RASTER columns (\_st\_intersects\_rast, etc)

Intersect operators on columns with `raster` type are supported. Please
submit a feature request via
[GitHub](https://github.com/hasura/graphql-engine) if you want support
for more functions.

For more details on intersect operators on raster columns and Postgres
equivalents, refer to the
`API reference <intersect_operators>`{.interpreted-text role="ref"}.

**Example: \_st\_intersects\_rast**

Filter the raster values which intersect the input raster value.

Executes the following SQL function:

```sql
boolean ST_Intersects( raster <raster-col> , raster <raster-value> );
```

  dummy_rast(where: {rast: {_st_intersects_rast: $rast}}){
    rid
    rast
  }


**Example: \_st\_intersects\_geom\_nband**

Filter the raster values which intersect the input geometry value and
optional band number.

Executes the following SQL function:

```sql
boolean ST_Intersects( raster <raster-col> , geometry geommin , integer nband=NULL );
```

  dummy_rast(where: {rast: {_st_intersects_geom_nband: {geommin: $point}}}){
    rid
    rast
  }


**Example: \_st\_intersects\_nband\_geom**

Filter the raster values (with specified band number) which intersect
the input geometry value.

Executes the following SQL function:

```sql
boolean ST_Intersects( raster <raster-col> , integer nband , geometry geommin );
```

  dummy_rast(where: {rast: {_st_intersects_nband_geom: {nband: 5 geommin: $point}}}){
    rid
    rast
  }


Filter based on failure of some criteria (\_not)
------------------------------------------------

The `_not` operator can be used to fetch results for which some
condition does not hold true. i.e. to invert the filter set for a
condition.

**Example: \_not**

Fetch all authors who don\'t have any published articles:

  author(
    where: {
      _not: {
        articles: { is_published: {_eq: true} }
      }
    }) {
    id
    name
    articles {
      title
      is_published
    }
  }


Using multiple filters in the same query (\_and, \_or)
------------------------------------------------------

You can group multiple parameters in the same `where` argument using the
`_and` or the `_or` operators to filter results based on more than one
criteria.

Note

You can use the `_or` and `_and` operators along with the `_not`
operator to create arbitrarily complex boolean expressions involving
multiple filtering criteria.

**Example: \_and**

Fetch a list of articles published in a specific time-frame (for
example: in year 2017):

  article (
    where: {
      _and: [
        { published_on: {_gte: \"2017-01-01\"}},
        { published_on: {_lte: \"2017-12-31\"}}
      ]
    }
  )
  {
    id
    title
    published_on
  }


Note

Certain `_and` expressions can be expressed in a simpler format using
some syntactic sugar. See the `API reference <AndExp>`{.interpreted-text
role="ref"} for more details.

**Example: \_or**

Fetch a list of articles rated more than 4 or published after
\"01/01/2018\":

  article (
    where: {
      _or: [
        {rating: {_gte: 4}},
        {published_on: {_gte: \"2018-01-01\"}}
      ]
    }
  )
  {
    id
    title
    rating
    published_on
  }


Note

The `_or` operator expects an array of expressions as input. If an
object is passed as input it will behave like the `_and` operator as
explained in the `API reference <OrExp>`{.interpreted-text role="ref"}

Filter nested objects
---------------------

The `where` argument can be used in **array relationships** as well to
filter the nested objects. **Object relationships** have only one nested
object and hence they do not expose the `where` argument.

**Example:**

Fetch all authors with only their 5 rated articles:

  author {
    id
    name
    articles(where: {rating: {_eq: 5}}) {
      title
      rating
    }
  }


Filter based on nested objects\' fields
---------------------------------------

You can use the fields of nested objects as well to filter your query
results.

For example:

```graphql
query {
  article (where: {author: {name: {_eq: "Sidney"}}}) {
    id
    title
  }
}
```

The behaviour of the comparision operators depends on whether the nested
objects are a single object related via an object relationship or an
array of objects related via an array relationship.

-   In case of an **object relationship**, a row will be returned if the
    single nested object satisfies the defined condition.
-   In case of an **array relationship**, a row will be returned if
    **any of the nested objects** satisfy the defined condition.

Let\'s look at a few use cases based on the above:

### Fetch if the single nested object defined via an object relationship satisfies a condition

**Example:**

Fetch all articles whose author\'s name starts with \"A\":

  article (
    where: {
      author: {
        name: { _similar: \"A%\"}
      }
    }
  ) {
    id
    title
    author {
      name
    }
  }


### Fetch if **any** of the nested objects defined via an array relationship satisfy a condition

**Example:**

Fetch all authors which have written at least one article which is rated
1:

  author(
    where: {
      articles: {rating: {_eq: 1}}
    }
  ) {
    id
    name
    articles {
      title
      rating
    }
  }


### Fetch if **all** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not: {inverse-of-condition}}`. This reads as: fetch if not (any of
the nested objects satisfy the inverted condition) i.e. all of the
nested objects satisfy the condition.

For example:

  -----------------------------------------------------------------------------------
  condition                             where expression
  ------------------------------------- ---------------------------------------------
  `{object: {field: {_eq: "value"}}}`   `{_not: {object: {field: {_neq: "value"}}}`

  `{object: {field: {_gt: "value"}}}`   `{_not: {object: {field: {_lte: "value"}}}`
  -----------------------------------------------------------------------------------

**Example:**

Fetch all authors which have all of their articles published i.e. have
`{is_published {_eq: true}`.

  author (
    where: {
      _not: {
        articles: {is_published: {_neq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }


### Fetch if **none** of the nested objects defined via an array relationship satisfy a condition

By default a row is returned if any of the nested objects satisfy a
condition. To achieve the above, we need to frame the `where` expression
as `{_not:ondition}`. This reads as: fetch if not (any of the nested
objects satisfy the condition) i.e. none of the nested objects satisy
the condition.

For example,

  ----------------------------------------------------------------------------------
  condition                             where expression
  ------------------------------------- --------------------------------------------
  `{object: {field: {_eq: "value"}}}`   `{_not: {object: {field: {_eq: "value"}}}`

  `{object: {field: {_gt: "value"}}}`   `{_not: {object: {field: {_gt: "value"}}}`
  ----------------------------------------------------------------------------------

**Example:**

Fetch all authors which have none of their articles published i.e. have
`{is_published {_eq: true}`:

  author (
    where: {
      _not: {
        articles: {is_published: {_eq: true}}
      }
    }
  ) {
    id
    name
    articles {
      title
      is_published
    }
  }


### Fetch if nested object(s) exist/do not exist

You can filter results based on if they have nested objects by checking
if any nested objects exist. This can be achieved by using the
expression `{}` which evaluates to `true` if any object exists.

**Example where nested object(s) exist:**

Fetch all authors which have at least one article written by them:

  author (
    where: {
      articles: {}
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }


**Example where nested object(s) do not exist:**

Fetch all authors which have not written any articles:

  author (
    where: {
      _not: {
        articles: {}
      }
    }
  ) {
    id
    name
    articles_aggregate {
      aggregate {
        count
      }
    }
  }


Cast a field to a different type before filtering (\_cast)
----------------------------------------------------------

The `_cast` operator can be used to cast a field to a different type,
which allows type-specific operators to be used on fields that otherwise
would not support them. Currently, only casting between PostGIS
`geometry` and `geography` types is supported.

Casting using `_cast` corresponds directly to [SQL type
casts](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS).

**Example: cast \`\`geometry\`\` to \`\`geography\`\`**

Filtering using `_st_d_within` over large distances can be inaccurate
for location data stored in `geometry` columns. For accurate queries,
cast the field to `geography` before comparing:

  cities(
    where: {location: {
      _cast: {geography: {
        _st_d_within: {from: $point, distance: $distance}
      }}
    }}
  ) {
    name
  }


**Example: cast \`\`geography\`\` to \`\`geometry\`\`**

Columns of type `geography` are more accurate, but they don't support as
many operations as `geometry`. Cast to `geometry` to use those
operations in a filter:

  cities(
    where: {location: {
      _cast: {geometry: {
        _st_within: $polygon
      }}
    }}
  ) {
    name
  }


Note

For performant queries that filter on casted fields, create an
[expression
index](https://www.postgresql.org/docs/current/indexes-expressional.html)
on the casted column. For example, if you frequently perform queries on
a field `location` of type `geometry` casted to type `geography`, you
should create an index like the following:

```sql
CREATE INDEX cities_location_geography ON cities USING GIST ((location::geography));
```

The TRUE expression ( **{ }** )
-------------------------------

The expression `{}` evaluates to `true` for all objects.

**For example**:

-   any query with the condition `{ where: {} }` will return all objects
    without applying any filter.
-   any query with the condition `{ where: { nested_object: {} } }` will
    return all objects for which atleast one `nested_object` exists.

Evaluation of **null** values in comparision expressions
--------------------------------------------------------

If in any comparision expression a `null` (or `undefined`) value is
passed, the expression currently gets reduced to `{}`
(`TRUE expression <true_expression>`{.interpreted-text role="ref"})

**For example**, the expression `{ where: { _eq: null } }` will be
reduced to `{ where: {} }`
