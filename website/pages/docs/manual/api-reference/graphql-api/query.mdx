
API Reference - Query / Subscription
====================================

Table of contents

**query** / **subscription** syntax
-----------------------------------

```
query|subscription [<op-name>] {
  object [([argument])]{
    object-fields
  }
}
```

  Key        Required   Schema                  Description
  ---------- ---------- ----------------------- ---------------------------------------------------------------------------
  op-name    false      Value                   Name query/subscription for observability
  object     true       [Object](#object)       Name of the table/object
  argument   false      [Argument](#argument)   One or more of filter criteria, instructions for sort order or pagination

**E.g. QUERY**:

```graphql
query {
  author(where: {articles: {rating: {_gte: 4}}} order_by: {name: asc}) {
    id
    name
  }
}
```

**E.g. SUBSCRIPTION**:

```graphql
subscription {
  author(where: {articles: rating: {_gte: 4}}} order_by: {name: asc}) {
    id
    name
  }
}
```

Note

For more examples and details of usage, please see
`this <queries>`{.interpreted-text role="ref"}.

**query\_by\_pk** / **subscription\_by\_pk** syntax
---------------------------------------------------

```
query|subscription [<op-name>] {
  <query-field-name> (
    column1: value1
    column2: value2
  )
  <object-fields>
}
```

  Key                Required   Schema   Description
  ------------------ ---------- -------- ----------------------------------------------------------------
  op-name            false      Value    Name query/subscription for observability
  query-field-name   true       Value    Name of the auto-generated query field, e.g. *article\_by\_pk*

**E.g. QUERY BY PK**:

```graphql
query {
  article_by_pk(id: 1) {
    id
    title
  }
}
```

**E.g. SUBSCRIPTION BY PK**:

```graphql
subscription {
  article_by_pk(id: 1) {
    id
    title
  }
}
```

Syntax definitions
------------------

### Object

[SimpleObject](#SimpleObject) \| [AggregateObject](#AggregateObject)

#### Simple object

```
object-name {
  field1
  field2
  json_field[(path: String)]
  ..
  nested object1
  nested object2
  aggregate nested object1
  ..
}
```

  Key    Required   Schema   Description
  ------ ---------- -------- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  path   false      Value    `path` argument of `json`/`jsonb` follows simple [JSONPath specification](https://github.com/json-path/JsonPath). However, prefix symbol `$.` is optional.

E.g.

```graphql
author {
   id  # scalar integer field

   name  # scalar text field

   address(path: "$.city") # scalar JSON field -> property
   address(path: "$.city.altitude") # scalar JSON field -> property -> property
   address(path: "city") # scalar JSON field -> property; '$.' prefix is optional
   contacts(path: "[0]") # scalar JSON field -> array_item
   contacts(path: "[0].phone") # scalar JSON field -> array_item_property
   contacts(path: "['Hello world!']") # scalar JSON field -> property; used for special characters key
   contacts(path: "[\"Hello world!\"]") # same as above; the syntax is ugly, but still works

   article {  # nested object
     title
   }

   article_aggregate {  # aggregate nested object
     aggregate {
       count
     }
     nodes {
       title
     }
   }
}
```

#### Aggregate object

```
object-name_aggregate {
  aggregate {
    count
    sum {
      field
      ..
    }
    avg {
      field
      ..
    }
    stddev {
      field
      ..
    }
    stddev_samp {
      field
      ..
    }
    stddev_pop {
      field
      ..
    }
    variance {
      field
      ..
    }
    var_samp {
      field
      ..
    }
    var_pop {
      field
      ..
    }
    max {
      field
      ..
    }
    min {
      field
      ..
    }
  nodes {
    field1
    field2
    ..
    nested object1
    nested object2
    aggregate nested object1
    ..
  }
}
```

(For more details on aggregate functions, refer to the [Postgres
docs](https://www.postgresql.org/docs/current/functions-aggregate.html#FUNCTIONS-AGGREGATE-STATISTICS-TABLE)).

E.g.

```graphql
author_aggregate {
  aggregate {
    count  # total count
    sum {
      id  # sum aggregate on id
    }
    avg {
      id  # avg aggregate on id
    }
    stddev {
      id  # stddev aggregate on id
    }
    stddev_samp {
      id  # stddev_samp aggregate on id
    }
    stddev_pop {
      id  # stddev_pop aggregate on id
    }
    variance {
      id  # variance aggregate on id
    }
    var_samp {
      id  # var_samp aggregate on id
    }
    var_pop {
      id  # var_pop aggregate on id
    }
    max {
      id  # max aggregate on id
    }
    min {
      id  # min aggregate on id
    }
  }

  nodes {  # objects
    id  # scalar field
    name  # scalar field

    article {  # nested object
      title
    }

    article_aggregate {  # aggregate nested object
      aggregate {
        count
      }
      nodes {
        title
      }
    }
  }
}
```

### Argument

[DistinctOnExp](#distinctonexp) \| [WhereExp](#whereexp) \|
[OrderByExp](#orderbyexp) \| [PaginationExp](#paginationexp)

#### DistinctOnExp

distinct\_on: \[ [TableSelectColumnEnum](#tableselectcolumnenum) \]

##### TableSelectColumnEnum

```graphql
#example table_select_column enum for "article" table
enum article_select_column {
  id
  title
  content
  author_id
  is_published
}
```

#### WhereExp

where: [BoolExp](#boolexp)

##### BoolExp

[AndExp](#andexp) \| [OrExp](#orexp) \| [NotExp](#notexp) \|
[TrueExp](#trueexp) \| [ColumnExp](#columnexp)

###### AndExp


{

:   \_and: \[[BoolExp](#boolexp)\]

}

Syntactic sugar

You can simplify an `_and` expression by passing the sub-expressions
separated by a `,`.

**For example:**

```graphql
{
  _and: [
    { rating: { _gte: 4 } },
    { published_on: { _gte: "2018-01-01" } }
  ]
}

# can be simplified to:

{
  rating: { _gte: 4 },
  published_on: { _gte: "2018-01-01" }
}
```

###### OrExp


{

:   \_or: \[[BoolExp](#boolexp)\]

}

Note

The `_or` operator expects an array of expressions as input. Passing an
object to it will result in the behaviour of the `_and` operator due to
the way [GraphQL list input
coercion](https://graphql.github.io/graphql-spec/June2018/#sec-Type-System.List)
behaves.

**For example:**

```graphql
{
  _or: {
   rating: { _gte: 4 },
   published_on: { _gte: "2018-01-01" }
  }
}

# will be coerced to:

{
  _or: [
    {
      rating: { _gte: 4 },
      published_on: { _gte: "2018-01-01" }
    }
  ]
}

# which is equivalent to:

{
  _or: [
    _and: [
      { rating: { _gte: 4 } },
      { published_on: { _gte: "2018-01-01" } }
    ]
  ]
}
```

###### NotExp


{

:   \_not: [BoolExp](#boolexp)

}

###### TrueExp

{}

###### ColumnExp


{

:   field-name : {[Operator](#operator): Value }

}

###### Operator

**Generic operators (all column types except json, jsonb):**

  Operator   PostgreSQL equivalent
  ---------- -----------------------
  `_eq`      `=`
  `_neq`     `<>`
  `_gt`      `>`
  `_lt`      `<`
  `_gte`     `>=`
  `_lte`     `<=`
  `_in`      `IN`
  `_nin`     `NOT IN`

(For more details, refer to the Postgres docs for [comparison
operators](https://www.postgresql.org/docs/current/functions-comparison.html)
and [list based search
operators](https://www.postgresql.org/docs/current/functions-comparisons.html).)

**Text related operators:**

  Operator      PostgreSQL equivalent
  ------------- -----------------------
  `_like`       `LIKE`
  `_nlike`      `NOT LIKE`
  `_ilike`      `ILIKE`
  `_nilike`     `NOT ILIKE`
  `_similar`    `SIMILAR TO`
  `_nsimilar`   `NOT SIMILAR TO`

(For more details on text related operators, refer to the [Postgres
docs](https://www.postgresql.org/docs/current/functions-matching.html).)

**Checking for NULL values:**

  Operator                                  PostgreSQL equivalent
  ----------------------------------------- -----------------------
  `_is_null` (takes true/false as values)   `IS NULL`

(For more details on the `IS NULL` expression, refer to the [Postgres
docs](https://www.postgresql.org/docs/current/functions-comparison.html).)

**Type casting:**

  Operator                                           PostgreSQL equivalent
  -------------------------------------------------- -----------------------
  `_cast` (takes a [CastExp](#castexp) as a value)   `::`

(For more details on type casting, refer to the [Postgres
docs](https://www.postgresql.org/docs/current/sql-createcast.html).)

**JSONB operators:**

  Operator          PostgreSQL equivalent
  ----------------- -----------------------
  `_contains`       `@>`
  `_contained_in`   `<@`
  `_has_key`        `?`
  `_has_keys_any`   `?!`
  `_has_keys_all`   `?&`

(For more details on JSONB operators, refer to the [Postgres
docs](https://www.postgresql.org/docs/current/static/functions-json.html#FUNCTIONS-JSONB-OP-TABLE).)

**PostGIS related operators on GEOMETRY columns:**

  Operator           PostGIS equivalent
  ------------------ --------------------------------
  `_st_contains`     `ST_Contains(column, input)`
  `_st_crosses`      `ST_Crosses(column, input)`
  `_st_equals`       `ST_Equals(column, input)`
  `_st_intersects`   `ST_Intersects(column, input)`
  `_st_overlaps`     `ST_Overlaps(column, input)`
  `_st_touches`      `ST_Touches(column, input)`
  `_st_within`       `ST_Within(column, input)`
  `_st_d_within`     `ST_DWithin(column, input)`

(For more details on spatial relationship operators, refer to the
[PostGIS
docs](http://postgis.net/workshops/postgis-intro/spatial_relationships.html).)

Note

-   All operators take a JSON representation of `geometry/geography`
    values as input value.

-   The input value for `_st_d_within` operator is an object:

    
    {

    :   field-name : {\_st\_d\_within: {distance: Float, from: Value} }

    }
    
**Intersect Operators on RASTER columns:**

  Operator                      PostgreSQL equivalent                     Input object
  ----------------------------- ----------------------------------------- ---------------------------------------------------------------------
  `_st_intersects_rast`         `ST_Intersects(column, value)`            `{ _st_intersects_rast: raster }`
  `_st_intersects_nband_geom`   `ST_Intersects(column, nband, geommin)`   `{ _st_intersects_nband_geom: {nband: Integer! geommin: geometry!}`
  `_st_intersects_geom_nband`   `ST_Intersects(column, geommin, nband)`   `{ _st_intersects_geom_nband: {geommin: geometry! nband: Integer }`

(For more details on intersect operators on `raster` columns refer to
the [PostGIS docs](https://postgis.net/docs/RT_ST_Intersects.html).)

###### CastExp

Note

Currently, only casting between `geometry` and `geography` types is
allowed.

#### OrderByExp

order\_by: ([TableOrderBy](#tableorderby) \| \[
[TableOrderBy](#tableorderby) \])

E.g.

order\_by: {id: desc}

or

order\_by: \[{id: desc}, {author: {id: asc}}\]

or

order\_by: {articles\_aggregate: {count: asc}}

##### TableOrderBy

For columns:

{column: [OrderByEnum](#orderbyenum)}

For object relations:

{relation-name: [TableOrderBy](#tableorderby)}

For array relations aggregate:

{relation-name\_aggregate: [AggregateOrderBy](#aggregateorderby)}

E.g.

Order by type for \"article\" table:

```graphql
input article_order_by {
  id: order_by
  title: order_by
  content: order_by
  author_id: order_by
  #order by using "author" object relationship columns
  author: author_order_by
  #order by using "likes" array relationship aggregates
  likes_aggregate: likes_aggregate_order_by
}
```

###### OrderByEnum

```graphql
#the order_by enum type
enum order_by {
  #in the ascending order, nulls last
  asc
  #in the ascending order, nulls last
  asc_nulls_last
  #in the ascending order, nulls first
  asc_nulls_first
  #in the descending order, nulls first
  desc
  #in the descending order, nulls first
  desc_nulls_first
  #in the descending order, nulls last
  desc_nulls_last
}
```

###### AggregateOrderBy

Count aggregate

{count: [OrderByEnum](#orderbyenum)}

Operation aggregate

{op\_name: [TableAggOpOrderBy](#tableaggoporderby)}

Available operations are `sum`, `avg`, `max`, `min`, `stddev`,
`stddev_samp`, `stddev_pop`, `variance`, `var_samp` and `var_pop`.

####### TableAggOpOrderBy

{column: [OrderByEnum](#orderbyenum)}

#### PaginationExp

limit: Integer \[offset: Integer\]
